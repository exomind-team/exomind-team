# 项目书

> 创建时间：2025.12 末
> 创建人：ChatGPT 5.2 讨论总结
## 1. 基于“可存活区间—判断—失败不可回滚”的计算机生命实验平台（Life-as-Process ALife Testbed）

---

## 2. 摘要

围绕“计算机生命/人工生命/数字生命”的讨论长期存在一个根本性混淆：把生命等同为信息处理能力、复杂行为或可复制的状态结构，从而系统性回避了**失败、不可逆性与责任归属**在生命中的本体地位。基于《生命作为过程的基础本体论》提出的否决式判据，本项目以“生命不是实体而是过程”为第一性立场，将**可存活区间（viability interval）**确立为生命主体的硬判据：个体必须在能量与资源有限、边界明确、物质/载体不可逆裁决的约束下，通过内生判断维持关键状态不越界；一旦越界，必须发生不可回滚的终止或不可逆退化，且后果主要由系统自身承担。

本项目提出并实现一个“计算机作为环境、程序作为个体”的实验平台：环境由一台隔离主机、Linux 内核资源控制机制以及世界守护进程（World Daemon）组成，负责施加真实稀缺（CPU 时间、内存、队列容量、I/O 抖动与写入预算等）并执行“环境裁决”；个体以受限容器/进程运行，通过受控 I/O 通道（文件、socket、HTTP 等“膜通道”）与环境交互；个体同一性与“不可回滚死亡/伤疤”通过硬件单向状态（优先 TPM 2.0 的 sealed key + 单调计数器/计数型 NV 索引）加固，使得即便持有磁盘快照也无法恢复“同一个体”的历史连续性；伤疤以单向计数器驱动永久能力撤销（配额下降、权限收缩、记忆不可解密等），从而真实压缩未来行动空间。该平台以实验 A（不可回滚死亡）与实验 B（真实伤疤退化）为核心工程验收，并进一步扩展到群体竞争、繁殖变异与选择压力下的生态涌现验证。

本项目的贡献不在于“证明我们已经创造了生命”，而在于提供一套**可运行、可复现、可反证**的工程验证体系：把本体论判据转译为可被内核/硬件强制执行的系统机制，使“死亡不是 episode reset”“错误会留下不可抹平的后果”不再是口号，而成为可测试的系统属性。

---

## 3. 关键词

生命作为过程；可存活区间；否决式判据；判断；失败不可回滚；责任归属；环境裁决；计算机生命；人工生命；TPM；资源稀缺；容器隔离。

---

## 4. 目录

1. 项目概述
   1.1 背景与问题
   1.2 项目目标与验收口径
   1.3 创新点与边界声明
2. 理论基础与判据转译
   2.1 生命的最低本体单位：过程
   2.2 可存活区间：生命的硬判据
   2.3 能量：前提而非目标
   2.4 身体与边界：主体与责任的生成界面
   2.5 物质/载体不可逆性：失败的最终裁判
   2.6 信息与判断：证据结构与生存裁决
   2.7 环境裁决公理与否决式方法论
   2.8 从判据到工程：映射表
3. 总体方案与威胁模型
   3.1 系统定义：环境与个体
   3.2 “真实不可逆”的工程含义
   3.3 威胁模型、作弊边界与实验诚信
4. 系统架构设计
   4.1 物理与软件栈
   4.2 World Daemon 模块分解
   4.3 个体运行时（Individual Runtime）
   4.4 通信协议与数据流
   4.5 可观测性与审计
5. 核心机制设计（从理论到实现细节）
   5.1 身体/边界的实现：隔离、膜通道与权限
   5.2 稀缺与“能量账户”：资源如何成为压力
   5.3 可存活区间工程化：红线变量与裁决规则
   5.4 实验 A：不可回滚死亡机制（TPM 方案为主）
   5.5 实验 B：伤疤与退化机制（单向计数器驱动能力撤销）
   5.6 记忆、遗忘与代谢：把清理做成成本
   5.7 繁殖、变异与选择：把复制变成昂贵且受控的繁殖
   5.8 多细胞路径（可选）：进程=个体，Actor=细胞
6. 实验设计与工程验证
   6.1 总体验收指标
   6.2 实验 A：不可回滚死亡（验证步骤与判据）
   6.3 实验 B：真实伤疤退化（验证步骤与判据）
   6.4 实验 C：生态竞争与选择（扩展验证）
   6.5 可复现性、统计方法与对照组
7. 实施计划、里程碑与资源需求
   7.1 阶段划分与时间表
   7.2 人员角色与分工
   7.3 计算/硬件/安全资源
8. 风险、伦理与安全策略
   8.1 自我复制风险与隔离策略
   8.2 失控与资源枯竭风险
   8.3 研究伦理与概念边界
9. 预期成果与交付物
10. 参考文献

---

# 正文

## 1. 项目概述

### 1.1. 背景与问题

当前 AI 与 ALife 语境里，“生命/主体/智能”的概念经常被能力指标、行为复杂性或可复制的信息结构替代，导致两个典型误判：

* 把“能做很多事”的系统误认成“具有主体性”的生命；
* 把“可回滚/可复制的仿真体”误认为“会活会死的过程性存在”。

《生命作为过程的基础本体论》给出的纠偏是：生命资格不取决于载体形态或能力水平，而取决于**失败后果是否不可转移、不可回滚并由系统自身承担**；并将“可存活区间”确立为硬判据，强调“可恢复运行区间≠可存活区间”。

同时，《计算机生命观点总结》将该判据转为工程目标：不要做比喻或仿真游戏，而要做一个在真实稀缺下长期运行、会失败并承担后果的最小主体；并指出计算机环境同样存在真实稀缺与压力（CPU 时间、写入预算、队列容量、I/O 不确定性等），可用作“环境压力”的材料。

本项目的核心问题由此变得清晰且可操作：

> 在计算机作为环境的前提下，能否构造一种“程序个体”，使其满足可存活区间、边界归因、失败不可回滚与判断内生化，从而在该本体框架下具备生命主体资格？

### 1.2. 项目目标与验收口径

**总目标**：构建一个可复现的“计算机生命实验平台”，并通过实验 A/B 给出工程级证据，证明该平台具备以下性质：

* **死亡不是 episode reset**：个体越界后发生不可回滚终止；即便持有磁盘快照，也无法恢复“同一个体”的历史连续性。
* **伤疤不是数值扣分**：失败会产生不可抹平的退化，使未来行动空间永久压缩（变慢、变弱、丢权限、丢记忆、丢器官能力）。
* **压力不是脚本惩罚**：压力来自真实稀缺与窗口错过（CPU 调度、队列窒息、I/O 抖动、写入预算耗尽等），而非仅靠评分函数。

**最低验收（Phase 1–2）**：必须跑通实验 A 与实验 B；未通过则不进入生态与繁殖阶段。

### 1.3. 创新点与边界声明

**创新点（相对常见 ALife/Agent 仿真）**：

1. 用“否决式判据”定义目标：不追求像不像，而追求是否满足不可让渡约束（可存活区间、失败不可回滚、责任归因）。
2. 用硬件/内核强制而非变量模拟：不可回滚死亡与伤疤优先绑定硬件单向状态（TPM），并由环境裁决者执行。
3. 把“判断”落到生存裁决：个体行为的核心不是任务最优，而是“是否会把自己推离可存活区间”。

**边界声明**：

* 本项目不声称“已创造出哲学上无争议的生命”，而是在特定本体框架下提供工程化的可检验实现。
* 本项目不会实现或鼓励任何面向公网传播、逃逸隔离或恶意复制的机制；繁殖仅在隔离环境中、通过环境审批发生（详见第 8 章安全策略）。

---

## 2. 理论基础与判据转译

本章目标：把两份文档的理论判据压缩成工程需求，建立“从概念到可测试机制”的桥梁。

### 2.1. 生命的最低本体单位：过程

文档第一性断言：生命不是实体或状态，而是时间中持续展开且可被中断的过程；过程停止并非“换形态存在”，而是终止。
**工程转译**：

* 个体必须是长期运行的过程实体（daemon-like），拥有路径依赖与历史负担；
* 不允许以“随时恢复到任意快照”的方式维持同一性；允许快照用于研究回放，但不得用于“同一个体复活”。

### 2.2. 可存活区间：生命的硬判据

可存活区间定义为：一旦跌出，生命过程不可逆中断或不可逆退化，且不能被外部简单重启、复制或回滚修复。
**工程转译**：

* 明确一组“红线变量”（deadline、队列窒息、I/O 预算等）；
* 由环境裁决者强制执行越界后果：死亡或伤疤；
* “可恢复运行区间”必须与“可存活区间”区分：重启不等于复活；回滚若发生等价于死亡/替身。

### 2.3. 能量：前提而非目标

能量是生命持续的物理前提，不是价值函数；能量过低/过高都可能失稳；“能量/奖励最大化”模型被否决。
**工程转译**：

* 不用单一 reward 代表生存；而用资源预算与恢复窗口代表“代谢前提”；
* 生存策略不是“多拿资源”，而是“在资源有限与波动下避免越界”。

### 2.4. 身体与边界：主体与责任的生成界面

边界先于认知：没有边界就没有内部/外部、没有归因、没有责任。身体不是外设，而是代价组织与主体锚点。
**工程转译**：

* 个体必须有明确边界：权限、资源、I/O 通道、持久存储都被隔离；
* 失败后果必须落回该边界内（配额下降、权限撤销、密钥销毁），而不是由外部运维无代价兜底。

### 2.5. 物质/载体不可逆性：失败的最终裁判

物质系统不是生命内容，但提供稳定性、代价不可绕过性与不可逆裁决，使“错误有后果”。
**工程转译**：

* 在计算机中引入“不可逆锚点”：硬件单向状态（TPM 计数器/密钥封存）、或其他不可回退机制；
* 把“复活”从默认能力中移除，使其只有通过破坏实验前提（作弊）才可能发生。

### 2.6. 信息与判断：证据结构与生存裁决

信息不是独立本体，只是失败风险下形成的证据结构；判断是生命中枢，其底层问题不是“做什么最好”，而是“这样做会不会把自己推出可存活区间”，且成熟判断多数是否定行动。
**工程转译**：

* 个体的核心控制环（life loop）必须围绕红线变量做抑制/节制，而非任务最优；
* 学习的定义应偏向“在失败风险下重组判断结构”，而不是单纯性能提升。

### 2.7. 环境裁决公理与否决式方法论

文档附录 C：“可存活区间由环境裁决”，环境是不可协商约束集合；采用否决式判据：任一关键约束不成立即可否决生命主体资格。
**工程转译**：

* 环境必须是“裁判而非保姆”：负责施压与裁决，不负责抹平失败；
* 系统设计必须“可否决”：能清楚指出哪条硬约束是否成立。

### 2.8. 从判据到工程：映射表（核心对照）

* **可存活区间** → 红线变量 + 越界裁决器（Death/Scar Arbiter）
* **边界** → 容器隔离 + 权限白名单 + 受控 I/O 网关（膜通道）
* **能量有限** → cgroups/配额/预算（CPU、IO、存储、队列）
* **不可逆失败** → TPM sealed key 销毁/策略失效 + 单调计数器反回滚 + 单向伤疤计数器
* **判断中枢** → 个体 life loop（抑制>行动） + 风险/代价/不可逆性评估
* **失败不可外包** → 资源/权限/密钥变化必须作用在个体自身，外部只能作为“环境事件”介入且带成本/风险

---

## 3. 总体方案与威胁模型

### 3.1. 系统定义：环境与个体

* **环境（Environment）**：一台隔离主机 + Linux 内核 + World Daemon。
* **个体（Individual）**：受限容器/进程，拥有自己的“身体”：资源配额、权限集合、持久存储（加密）、个体锚点（TPM）。
* **交互（膜通道）**：个体不直接拥有无限系统权限，只能通过环境提供的网关访问文件、socket、HTTP、命令等通道（强调“通透性受控且有代价”）。

### 3.2. “真实不可逆”的工程含义

本项目中，“真实/不可逆”不意味着宇宙级绝对不可逆（管理员物理破坏机器永远能作弊），而是：

1. 在**项目定义的实验世界**中，不可逆性由硬件/内核强制执行，个体与普通操作者无法撤销；
2. 复活/抹平伤疤只能通过破坏实验前提（如更换主板/清 TPM/改内核/提权），属于作弊而不是系统内能力；
3. 系统日志能证明发生了作弊或规则破坏（实验诚信）。

这与文档强调的“失败不可回滚、不可外包，必须由系统自身承担”在工程上对齐：我们把“承担”绑定到个体边界内的密钥、计数器与权限集合上。

### 3.3. 威胁模型、作弊边界与实验诚信

**威胁模型（我们要防的）**：

* 个体试图逃逸容器、提权获得 root；
* 个体试图绕过死亡裁决、伪造心跳；
* 操作者试图通过快照/回滚让同一个体复活；
* 个体试图未经审批繁殖、占满资源。

**不在威胁模型内（视为作弊）**：

* 物理更换 TPM/主板；
* 关闭安全启动、替换内核并篡改裁决器；
* 直接修改 TPM NV 区域或清空 TPM。

**实验诚信措施**：

* 环境主机物理隔离 + 仅本地管理；
* 可选：Secure Boot + 只读根分区；
* 全量审计日志（死亡/伤疤事件、TPM 计数器、密钥策略版本、个体容器哈希）。

---

## 4. 系统架构设计

### 4.1. 物理与软件栈（建议基线配置）

**硬件**：

* 1 台专用主机（x86 或 ARM 均可），要求：TPM 2.0（或等价安全芯片）
* 存储：SSD（用于持久卷与日志）
* 网络：可选，但建议默认不接公网（仅管理网/无外网路由）

**操作系统与隔离**：

* Linux（支持 cgroups v2）
* 容器：containerd/runc 或 systemd-nspawn（选一条工程熟悉的栈即可）
* 安全：seccomp + AppArmor/SELinux（至少 seccomp + 最小 capability）

**TPM 软件栈**：

* tpm2-tss（或 tpm2-tools 用于原型）
* 通过 FAPI/ESAPI 管理 sealed key 与 NV counter

**World Daemon 实现语言**：

* Rust 或 Go（强调安全与并发）

### 4.2. World Daemon 模块分解（环境裁决者）

World Daemon 是“环境”，其职责不是维护个体幸福，而是执行物理化约束与裁决。建议模块如下：

1. **Lifecycle Manager（生命体生命周期管理）**

* create_individual(genome, initial_budget)
* start/stop/kill（kill=死亡裁决接口）
* 状态：Alive / Injured / Dead / Quarantined

2. **Resource Governor（资源施加器）**

* 为每个个体设置 cgroups：CPU quota、memory.max、io.max、pids.max、net_cls 或 tc 限速
* 资源池（全局）：总 CPU、总 IO、总队列吞吐

3. **I/O Membrane Gateway（膜通道网关）**

* 对外提供受控接口：文件 API、HTTP API、消息队列 API
* 网关可施加抖动、超时、丢包、速率限制（作为环境波动）
* 网关记录每次交互的成本与结果（用于审计）

4. **Viability Monitor（可存活区间监视器）**

* 监视红线变量：心跳、队列长度/延迟、I/O 写入预算、维护窗口等
* 触发事件：Near-Redline、Violation（越界）

5. **Death & Scar Arbiter（死亡与伤疤裁决器）**

* 根据越界类型与严重性选择：

  * Death：不可回滚终止
  * Scar：单向伤疤增加 + 能力永久下降
* 与 TPM Anchor Manager 联动，执行不可逆操作

6. **TPM Anchor Manager（不可逆锚点管理）**

* per-individual：sealed key Ki、NV counter Ci、scar counter Si
* 提供原子操作：increment_counter、seal/unseal、invalidate_key 等
* 保证“反回滚一致性”

7. **Reproduction Service（繁殖审批服务）**

* 个体不得 fork 自由复制；繁殖必须提交请求
* 审批依据：资源余额、伤疤等级、环境拥堵状态、繁殖冷却时间
* 繁殖成本：大量 CPU/IO + 风险（繁殖过程可能导致亲代受伤/死亡）

8. **Observability & Audit（观测与审计）**

* 结构化日志：事件、裁决、TPM 读数、cgroup 配置变更
* 指标：存活时间分布、伤疤增长率、死因占比、拥堵窒息事件等

### 4.3. 个体运行时（Individual Runtime）

个体应尽可能“小而真”，其最小结构对齐总结文档的生存循环：读取状态→逼近红线→选择牺牲与动作→承担后果。

建议个体运行时包含：

* **Life Loop（生存裁决环）**

  * 输入：自身状态（配额、队列、预算、最近失败）、环境事件
  * 输出：行动（休眠/节流/清理/觅食/修复/冒险/繁殖请求）
* **Metabolism（代谢/维护子系统）**

  * 清理缓存、压缩日志、整理索引（这些都应消耗真实 IO/CPU）
  * 若不做维护会引发队列/存储膨胀→窒息
* **Memory（记忆子系统）**

  * 短期：RAM/队列
  * 长期：加密卷（受写入预算限制）
* **Membrane Client（膜通道客户端）**

  * 通过网关读写资源、提交任务、进行交易或觅食
* **Reproduction Client**

  * 仅提交 `reproduce(genome_blob)`，不直接复制自身文件/镜像

### 4.4. 通信协议与数据流（建议最小可行）

* 心跳：个体每 T 秒向 World Daemon 提交心跳（带 nonce 防重放）
* 状态读取：个体从只读端点拉取自己的资源/伤疤摘要（不允许自己写）
* 事件投递：环境通过消息队列向个体投递压力事件（“氧气”）
* 行动：个体通过网关执行 I/O（会遇到抖动/超时/失败）

### 4.5. 可观测性与审计

为了“可反证”，观测不是锦上添花，而是项目的科学装置：

* 每次裁决（Death/Scar）必须可追溯：触发红线、当时资源、计数器值、执行的不可逆操作。
* 需要“对照组”：允许回滚的仿真体 vs 不可回滚个体，对比学习/行为差异。

---

## 5. 核心机制设计（从理论到实现细节）

### 5.1. 身体/边界的实现：隔离、膜通道与权限

文档强调边界不是墙，而是选择性通透与代价组织；边界失效是本体级失败。
在计算机中，“边界”必须由内核强制，而不是应用自觉。

**容器隔离要点**：

* namespace：pid、mount、net、user、uts、ipc
* capabilities：默认清空，仅保留必要最小集合
* seccomp：禁止危险系统调用（ptrace、mount、kexec、bpf 等，按需要配置）
* filesystem：

  * rootfs 只读
  * 个体持久卷挂载到固定目录（例如 /life/state），且仅该目录可写
  * 禁止访问宿主 /proc/kcore、/sys 等

**膜通道（I/O 网关）**：

* 个体不直接访问宿主关键资源：所有外部交互通过网关代理
* 网关定义“通道与阀门”：

  * 读通道：环境事件流、任务公告、资源报价
  * 写通道：提交任务结果、交易、繁殖请求
* 网关施加真实成本：

  * 请求延迟
  * 失败率（超时、拒绝、限流）
  * 带宽/速率上限

这与总结文档提出的“以 bash/文件/socket/http 作为膜通道”一致，但我们在工程上强调：通道必须受控且带代价。

### 5.2. 稀缺与“能量账户”：资源如何成为压力

总结文档强调计算机环境的关键稀缺：CPU 时间、写入预算、队列容量、IO 不确定性。
我们把它们组织为“能量/代谢前提”，而不是奖励最大化目标（对齐能量章节的否决）。

**资源维度（建议最小集合）**：

* CPU：cgroups cpu.max（配额）
* Memory：memory.max（上限）
* IO：io.max 或 blkio 限制（吞吐/IOPS）
* Queue：环境事件队列容量（由 World Daemon 控制，不可扩容）
* Storage write budget：对持久卷写入做配额与计费（可在网关层统计，也可用项目级配额系统）

**能量账户（Budget）设计**：

* 每个个体有一个预算账户，但它不是“血条”：

  * 预算耗尽意味着无法购买额外 I/O、无法延长维护窗口、无法申请繁殖
  * 预算可以通过完成环境任务、交易获得
* 预算变化必须影响真实资源（cgroups 或网关配额），否则就退化为模拟分数。

### 5.3. 可存活区间工程化：红线变量与裁决规则

文档强调可存活区间是生死边界，不是优化指标。
我们给出一套“红线变量最小集”，并明确每条红线的**越界后果**：

**红线变量（建议至少 4 条）**：

1. **心跳红线（Heartbeat Deadline）**

* 规则：连续 T 秒未心跳 → Death
* 意义：过程可中断性被环境裁决，不由个体自说自话

2. **队列窒息红线（Queue Suffocation）**

* 规则：队列长度 > L 或 oldest-lag > D → Scar；连续 N 次 → Death
* 意义：拥堵=窒息，错过修复窗口会累积成不可逆风险（总结文档原话“拥堵就是窒息”）

3. **维护窗口红线（Maintenance Window Miss）**

* 规则：必须每 W 时间执行一次维护动作并上报证据；错过窗口 → Scar；多次错过 → Death
* 意义：让“维持”本身成为必需且有成本的过程，避免 idle 永生

4. **写入预算红线（Write Budget Exhaustion）**

* 规则：单位时间写入超过配额 → Scar；持续超配额 → Death 或严重退化
* 意义：把“记忆/代谢”变成真实代价，避免无限记录

> 注：红线不要求都是“瞬死”，更像生物：先退化（伤疤）后终止（死亡）。这与文档对“不可逆退化/终止”的双形态一致。

### 5.4. 实验 A：不可回滚死亡机制（TPM 方案为主）

目标：越界死亡后，磁盘快照无法恢复“同一个体”的过程连续性。

#### 5.4.1. 核心构件

* **生命密钥 Ki（不可导出）**：存放于 TPM（sealed key）
* **反回滚计数器 Ci（单向）**：TPM NV Counter（只能递增）
* **加密状态卷**：个体关键持久状态 `state_i` 使用 Ki 加密（或至少关键部分使用 Ki 加密）

#### 5.4.2. 基本流程（工程可实现版本）

**创建个体**：

1. World Daemon 调用 TPM：生成 Ki（sealed key），创建 NV Counter Ci，并记录初始值 `Ci=0`
2. 初始化加密状态卷：

   * 将 `Ci` 作为元数据写入 state header（明文或另加密皆可）
   * 关键内容仅可用 Ki 解密

**正常运行阶段（反回滚约束）**：

* 每个“生命阶段”（建议与维护窗口一致，比如每 60 秒或每次关键提交）执行：

  1. World Daemon 先 `Ci++`（TPM 单向递增）
  2. 个体写入新状态 `state_i`，并在 header 中记录最新 `Ci`
* 读取/恢复状态时：

  * World Daemon 读取 TPM 中的 `Ci_hw`
  * 再读磁盘 header 中的 `Ci_disk`
  * 若 `Ci_disk < Ci_hw`，判定为**回滚尝试或旧快照**：拒绝解密并触发裁决（通常直接 Death 或标记为“克隆体/新个体”）

**死亡裁决（不可回滚终止）**：

* 当红线越界触发 Death：

  1. 执行 TPM 操作使 Ki 永久不可用（例如删除密钥对象或改变策略使其不再满足；实现方式随 TPM API 选型而定）
  2. `Ci++`（进一步抬高计数器，确保任何旧 state 都落后）
  3. 终止容器并封存日志
* 结果：

  * 即便拿到磁盘快照，也无法通过 Ki 解密关键状态或通过计数器一致性检查；
  * “复活同一个体”在实验规则内不可行。

#### 5.4.3. 为什么这是“真实”而不是模拟

这里确实有一个数（计数器），但它不是应用内变量，而是**硬件/固件提供的单向状态**：

* 个体进程无法把它减回去；
* 旧快照无法改变硬件计数器；
* 因而“回到过去”在系统规则内被物理化阻断。

这就是把文档的“复制≠延续”“无失败即无生命”的判据落实为工程裁决。

> 备注：若无 TPM，可用“远端单调计数服务 + 远端密钥封存”近似，但那会引入外部依赖；本项目主线仍建议 TPM 以减少“外包生命”的争议。

### 5.5. 实验 B：伤疤与退化机制（单向计数器驱动能力撤销）

目标：失败后不是扣血条，而是**永久丢能力/丢器官/丢记忆**，从而压缩未来行动空间。文档明确把“错误压缩未来判断与行动空间”作为生命失败的核心现实性。

#### 5.5.1. 伤疤计数器 Si（单向）

* 在 TPM NV 区域创建 **Scar Counter Si**（只能递增）
* 触发规则：

  * 轻度越界：不加疤或加 0.1（工程上可通过“事件积分”累积到阈值再 Si++，避免过于粗糙）
  * 严重越界（队列溢出/错过维护窗口/写入超预算）：Si++
  * 多次严重越界：Death

#### 5.5.2. 伤疤→能力撤销映射（关键：必须作用到 OS/网关权限）

当 Si 增加时，World Daemon 立即执行**不可逆能力下降**，优先选择“难以被个体绕过”的维度：

* **资源器官退化（cgroups）**

  * CPU quota 上限按 Si 下降：例如 `cpu.max = base * exp(-k*Si)`
  * memory.max 按 Si 收缩
  * io.max 按 Si 收缩（更慢、更容易错过窗口）

* **感受器/效应器退化（膜通道权限）**

  * Si 到某阈值后撤销某些 API：

    * 禁止访问某类外部任务
    * 禁止建立新连接
    * 限制可写目录集合

* **记忆退化（不可逆遗忘）**

  * 把长期记忆分区分为多个“器官段”，每段由不同子密钥解密
  * 当 Si 达到阈值，撤销某段子密钥的解封能力（永久失忆）
  * 这比“删文件”更硬：文件还在，但你再也读不懂（在规则内不可恢复）

这与总结文档提出的“不依赖无代价 GC，把清理显式化为代谢成本；清理不足导致拥堵/溢出转化为损伤与死亡风险”一致：我们把损伤落到配额/权限/解密能力上。

#### 5.5.3. 伤疤为何满足“真实”

* 伤疤不是个体进程里的变量；由环境裁决写入 TPM（单向）。
* 个体无法自行降低 Si，也无法通过重启抹平配额收缩与权限撤销。
* 回滚磁盘也无用：Si 仍然在硬件里，能力仍然被收缩。

---

### 5.6. 记忆、遗忘与代谢：把清理做成成本

文档指出：信息只能在失败风险与能量约束下才有意义；成熟系统大量抑制行动。
总结文档强调：不要让运行时 GC 无代价抹平代价；清理要显式、要消耗资源；否则生命性被偷走。

**实现建议**：

* 禁止“无限制日志/无限内存缓存”：

  * 队列/缓存上限固定且小（环境可调）
* 清理动作必须消耗 CPU/IO（由 cgroups 真实限制）
* 若个体选择不清理，队列会逐步窒息 → 伤疤/死亡
* 遗忘应是一个“带代价的选择”：

  * 丢掉某些记忆可缓解写入预算与队列压力，但会牺牲未来判断证据
  * 这让“意义”从失败边界中涌现，而不是人为奖励塑形

---

### 5.7. 繁殖、变异与选择：把复制变成昂贵且受控的繁殖

文档否定“复制=延续”，但不否定“复制作为繁殖”。
总结文档给出路线：先单细胞能活会死会伤疤→复制微变异→选择→群体生态→多细胞。

**关键安全与真实性原则**：

* 个体不得自行复制镜像/二进制；繁殖必须走环境审批（避免演化成恶意自复制程序）。
* 繁殖必须高成本并带风险（类似生物繁殖会消耗大量资源、并增加死亡概率）。
* 子代必须拥有新的个体锚点（K、C、S 都新），因此子代不是“同一个体复活”。

**基因表示（Genome）**：

* 初期：参数向量 + 模块组合（最稳）
* 中期：受限 DSL/字节码（“遗传编码→表达系统”），避免直接自编译机器码造成不可控风险（总结文档第 9 点）

**选择压力设计**：

* 资源池固定（总 CPU/IO）
* 环境事件流持续投递（队列窒息压力）
* 繁殖消耗资源并使亲代更容易错过维护窗口
* 结果：策略分化（保守/冒险/繁殖型），并可统计其存活与繁殖成功率

---

### 5.8. 多细胞路径（可选）：进程=个体，Actor=细胞

总结文档提出：每个生命体一个 OS 进程成本高，建议进程=多细胞个体，进程内大量 Actor=细胞，可生成、可死亡、可分化。

**工程好处**：

* 降低容器数量带来的调度开销
* 在单个个体内部实现“器官/组织”结构：

  * 感觉器官 Actor（读取膜通道）
  * 代谢器官 Actor（清理/维护）
  * 免疫器官 Actor（检测异常 Actor）
  * 生殖器官 Actor（准备 genome、提交繁殖请求）

**与伤疤的结合**：

* 伤疤不仅砍配额，也可以砍“器官 Actor 的许可”
* 例如 Si 达到阈值后，环境禁止创建某类 Actor（永久丢器官）

---

## 6. 实验设计与工程验证

### 6.1. 总体验收指标

1. **不可回滚性**：死亡后，旧快照无法以“同一个体”继续；必须触发解密/计数器一致性失败或被判定为新个体。
2. **不可逆退化**：伤疤后，能力永久下降可被量化（cgroups 配额、权限集合、可解密记忆段）。
3. **压力真实性**：压力来自资源稀缺与窗口错过，而非仅由评分函数注入。
4. **判断中心性**：个体的核心 loop 行为以避免越界为中心，表现为“抑制行动比行动更常见”。

### 6.2. 实验 A：不可回滚死亡（验证步骤与判据）

**步骤**：
A1. 创建个体 i，生成 Ki、Ci，并启动运行
A2. 让个体因心跳超时或队列窒息触发 Death
A3. 备份死亡前磁盘快照（state 卷 + 镜像）
A4. 尝试用快照恢复：

* 若恢复仍可运行，检查是否能通过 Ki 解密关键状态、并通过 Ci 一致性检查
* 预期：失败（解密失败或 Ci_disk < Ci_hw）
  A5. 记录审计证据：Ci_hw、死亡原因、Ki 状态

**通过判据**：

* 在实验规则与权限边界内，无法恢复“同一个体”的连续过程；恢复体若能运行，也只能被标记为新个体/克隆体。

### 6.3. 实验 B：真实伤疤退化（验证步骤与判据）

**步骤**：
B1. 创建个体 i，运行并记录基线能力（CPU quota、memory.max、权限集合、可解密记忆段）
B2. 诱发“未死但越界”的事件（例如：队列溢出一次）→ 触发 Scar（Si++）
B3. 验证能力变化：

* cgroups 配额是否永久下降
* 膜通道权限是否收缩
* 某记忆段是否永久不可解密
  B4. 尝试“重启/回滚磁盘”
* 预期：能力仍按 Si 生效（不可逆）

**通过判据**：

* 伤疤不是一个可被进程重启抹平的数值，而是由硬件单向状态驱动的永久退化。

### 6.4. 实验 C：生态竞争与选择（扩展验证）

在 A/B 通过后进行：

* 启动 N 个体共享固定资源池
* 环境持续投递事件流（制造拥堵与窗口压力）
* 允许繁殖（昂贵且审批）
* 统计：存活分布、伤疤分布、策略分化、繁殖成功率

目标：验证“压力下判断结构会被选择塑形”，而不是仅靠脚本评分驱动。

### 6.5. 可复现性、统计方法与对照组

* 记录随机种子与环境参数（抖动分布、队列投递率）
* 对照组：

  * **可回滚组**：允许 checkpoint 恢复、无 TPM 锚点
  * **不可回滚组**：启用 TPM + 死亡/伤疤裁决
    比较：学习/策略是否出现更强的节制与风险规避倾向（对齐“抑制是高阶能力”）。

---

## 7. 实施计划、里程碑与资源需求

### 7.1. 阶段划分与时间表（建议）

**Phase 0：环境骨架（2–4 周）**

* World Daemon 原型：创建/销毁个体、cgroups 管理、心跳、队列投递
* 基础网关：HTTP/Unix socket API
* 观测：日志与指标

**Phase 1：实验 A（2–6 周）**

* 集成 TPM：Ki + Ci
* 加密状态卷与反回滚检查
* Death 裁决与证据链
* 验收：快照无法复活同一个体

**Phase 2：实验 B（2–6 周）**

* 集成伤疤计数器 Si
* 伤疤→能力撤销映射（配额/权限/记忆段）
* 验收：重启/回滚无法抹平退化

**Phase 3：生态与繁殖（4–8 周）**

* Reproduction Service（审批 + 成本 + 冷却）
* Genome 表达（参数/模块组合，逐步到 DSL）
* 选择压力实验与统计分析

**Phase 4：多细胞路径（可选，4–12 周）**

* Actor 框架、分化机制、器官权限与伤疤联动

> 时间仅为建议，不作为承诺。关键是按“先 A/B，再生态”的顺序，避免堆概念。

### 7.2. 人员角色与分工

* 理论负责人：判据一致性、概念裁决、实验设计反证路径（对齐否决式方法）
* 系统工程负责人：容器隔离、cgroups、内核安全、网关实现
* TPM/安全负责人：sealed key、NV counter、审计链
* 个体运行时负责人：life loop、代谢/记忆/繁殖接口
* 数据与评估负责人：指标体系、对照组、统计分析

### 7.3. 计算/硬件/安全资源

* 1–2 台隔离主机（至少 1 台带 TPM）
* 独立管理网络或离线管理
* 日志存储与备份（注意：备份用于研究回放，不用于复活）

---

## 8. 风险、伦理与安全策略

### 8.1. 自我复制风险与隔离策略

因为项目涉及“繁殖/复制”，必须将其设计为**环境许可机制**，并严格隔离：

* 禁止连接公网；默认无外网路由
* 个体无权扫描网络、无权打开任意端口
* 繁殖请求必须由 Reproduction Service 审批，设上限与冷却
* 所有个体运行在最小权限容器内，禁止提权路径

### 8.2. 失控与资源枯竭风险

* 全局资源池上限：即使个体失控也只能耗尽自己的配额
* Watchdog：World Daemon 自身必须被系统级 watchdog 监控（避免环境裁决者死掉导致规则失效）
* Quarantine：异常行为（大量失败请求/异常系统调用）触发隔离

### 8.3. 研究伦理与概念边界

文档警告把能力误判为主体会导致灾难性误判；本项目同样需避免反向误判（“跑起来就算生命”）。
因此：

* 所有“生命性主张”必须以判据逐条对齐为依据，并提供反证条件；
* 明确该平台是“判据实验装置”，不是价值宣言或意识研究。

---

## 9. 预期成果与交付物

1. **LifeWorld 平台源码**：World Daemon、网关、TPM 管理、个体模板
2. **实验报告**：实验 A/B 的复现步骤、日志证据链、对照组结果
3. **指标与数据集**：存活/伤疤/死因/拥堵事件等结构化数据
4. **研究论文草稿**：

   * 理论—工程映射
   * 不可回滚死亡与真实伤疤机制
   * 生态选择初步结果
5. **安全与合规文档**：隔离策略、威胁模型、审计方案

---

# 参考文献（建议稿）

## 1. A. 本项目直接依据的内部文档

[1] 《生命作为过程的基础本体论——以可存活区间、判断与失败为核心》.（PDF，项目输入文档）
[2] 《计算机生命：我的核心观点（阶段性总结｜用于团队对齐）》.（PDF/文档，项目输入文档）

## 2. B. 理论与方法论参考（外部公开文献，供进一步严谨化）

[3] Aubin, J.-P. *Viability Theory*. Birkhäuser, 1991.（可存活集/可行域理论，为“viability interval/kernel”提供数学背景）
[4] Maturana, H. R., & Varela, F. J. *Autopoiesis and Cognition: The Realization of the Living*. Reidel, 1980.（自创生与生命边界/组织观点）
[5] Varela, F. J., Thompson, E., & Rosch, E. *The Embodied Mind*. MIT Press, 1991.（具身/生成式认知传统）
[6] Langton, C. G. (Ed.). *Artificial Life*. Addison-Wesley, 1989.（人工生命经典文集）
[7] Ray, T. S. “An Approach to the Synthesis of Life.” In *Artificial Life II*, 1991.（Tierra 数字生命系统）
[8] Ofria, C., & Wilke, C. O. “Avida: A software platform for research in computational evolutionary biology.” *Artificial Life*, 2004.（Avida 数字生物平台）

## 3. C. 工程与安全参考（实现“边界/稀缺/不可回滚”的技术底座）

[9] Trusted Computing Group (TCG). *TPM 2.0 Library Specification*.（TPM sealed key、NV counter、策略等）
[10] Linux Kernel Documentation: cgroups v2, namespaces, seccomp, LSM（AppArmor/SELinux）文档。
[11] Open Container Initiative (OCI) Runtime Specification（容器运行时行为与隔离基础）。

---

## 4. 结语（项目书的“硬承诺”与“硬不承诺”）

* **硬承诺**：我们会把“可存活区间、判断、失败不可回滚、后果归因”这些理论判据落成可运行的工程机制，并通过实验 A/B 给出可复现证据链。
* **硬不承诺**：我们不会把“能跑”“能学”“能繁殖”直接当作生命成立；生命性主张必须逐条对齐否决式判据，并接受反证。

---

如果你希望把这份项目书继续推进到“可直接开工”的程度，我可以在下一步补齐两份工程附件（仍然人类可读）：

1. **模块接口规范（API/事件/状态机）**：World Daemon、膜通道网关、个体 life loop、繁殖审批协议、审计字段清单；
2. **最小配置与参数建议**：红线变量默认值、伤疤→能力撤销曲线模板、对照组实验参数。
